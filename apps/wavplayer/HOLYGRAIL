if (Pip.removeSubmenu) Pip.removeSubmenu();
delete Pip.removeSubmenu;
if (Pip.remove) Pip.remove();
delete Pip.remove;

// The key clue from asteroids.js: reset the global graphics state.
g.clear();

var G = Graphics.createArrayBuffer(400, 308, 2, {
  msb: true,
  buffer: E.toArrayBuffer(E.memoryArea(0x10000000 + 16384, (400 * 308) >> 2))
});
G.flip = function() { return Pip.blitImage(G, 40, 7); };

var wavFiles = [];
var allFiles = [];
var errorMsg = "";
var playMsgLines = [];
try {
  allFiles = require("fs").readdirSync("/ALARM");
  // Filter out any potential silence file from the main list
  wavFiles = allFiles.filter(function(f) { return f.toLowerCase().endsWith(".wav") && !f.toLowerCase().endsWith("_silence.wav"); });
} catch (e) {
  errorMsg = "ERROR: " + e;
  wavFiles = [];
}

var selected = 0;
var currentPage = 0;
var isPlaying = false;
var LEFT_MARGIN = 30;
var HEADER_HEIGHT = 35;
var UNDERLINE_Y = HEADER_HEIGHT + 20;
var LIST_START_Y = UNDERLINE_Y + 20;
var LINE_HEIGHT = 24;
var FILES_PER_PAGE = 6;
var statusTimeout = null;
var needsRedraw = true;

const COLOR_GREEN = 3; // With g.clear(), this should now be the correct bright green.
const COLOR_BLACK = 0;

function drawMenu() {
  G.clear(COLOR_BLACK);
  
  G.setColor(COLOR_GREEN).setFontMonofonto28();
  var headerText = "AUDIO PLAYER";
  var headerWidth = G.stringWidth(headerText);
  var headerX = Math.floor((G.getWidth() - headerWidth) / 2);
  G.drawString(headerText, headerX, 15);
  
  // Updated to draw the line from edge to edge.
  G.setColor(COLOR_GREEN).fillRect(0, UNDERLINE_Y, G.getWidth(), UNDERLINE_Y + 3);

  var y = LIST_START_Y;
  
  if (!wavFiles.length) {
    G.setFontMonofonto23();
    G.setColor(COLOR_GREEN);
    var noFilesText = "NO WAV FILES FOUND";
    var noFilesWidth = G.stringWidth(noFilesText);
    var noFilesX = Math.floor((G.getWidth() - noFilesWidth) / 2);
    G.drawString(noFilesText, noFilesX, G.getHeight() / 2);
    G.setColor(COLOR_GREEN).drawRect(LEFT_MARGIN, G.getHeight() / 2 - 20, G.getWidth() - LEFT_MARGIN, G.getHeight() / 2 + 40);
    G.flip();
    return;
  }

  var totalPages = Math.ceil(wavFiles.length / FILES_PER_PAGE);
  var startIndex = currentPage * FILES_PER_PAGE;
  var endIndex = Math.min(startIndex + FILES_PER_PAGE, wavFiles.length);
  var filesOnPage = wavFiles.slice(startIndex, endIndex);

  var listDrawY = y;
  if (totalPages > 1) {
    G.setFontMonofonto16();
    G.setColor(COLOR_GREEN);
    var pageInfo = "PAGE " + (currentPage + 1) + "/" + totalPages;
    var pageInfoWidth = G.stringWidth(pageInfo);
    G.drawString(pageInfo, G.getWidth() - pageInfoWidth - LEFT_MARGIN, y);
    listDrawY += 25;
  }
  
  G.setFontMonofonto16();

  filesOnPage.forEach(function(name, i) {
    var actualIndex = startIndex + i;
    var rowY = listDrawY + i * LINE_HEIGHT;
    
    if (actualIndex === selected) {
      var boxPadding = (LINE_HEIGHT - 16) / 2;
      var boxTop = rowY - boxPadding;
      var boxHeight = LINE_HEIGHT;
      G.setColor(COLOR_GREEN).fillRect(LEFT_MARGIN - 5, boxTop, G.getWidth() - LEFT_MARGIN + 5, boxTop + boxHeight);
      G.setColor(COLOR_BLACK);
    } else {
      G.setColor(COLOR_GREEN);
    }
    var displayName = name;
    if (G.stringWidth(displayName) > G.getWidth() - LEFT_MARGIN - 40) {
      while (G.stringWidth(displayName + "...") > G.getWidth() - LEFT_MARGIN - 40 && displayName.length > 0) {
        displayName = displayName.slice(0, -1);
      }
      displayName += "...";
    }
    G.drawString(displayName, LEFT_MARGIN, rowY);
  });

  if (playMsgLines.length) {
    var boxWidth = 360;
    var boxHeight = 20 * Math.min(6, playMsgLines.length) + 30;
    var boxX = Math.floor((G.getWidth() - boxWidth) / 2);
    var boxY = Math.floor((G.getHeight() - boxHeight) / 2);

    G.setColor(COLOR_GREEN).fillRect(boxX - 3, boxY - 3, boxX + boxWidth + 3, boxY + boxHeight + 3);
    G.setColor(COLOR_BLACK).fillRect(boxX, boxY, boxX + boxWidth, boxY + boxHeight);

    var hasSuccess = playMsgLines.some(function(line) { return line.includes("SUCCESS"); });
    var hasError = playMsgLines.some(function(line) { return line.includes("FAILED") || line.includes("WARNING"); });

    if (hasSuccess) {
      G.setColor(COLOR_GREEN).drawRect(boxX + 2, boxY + 2, boxX + boxWidth - 2, boxY + boxHeight - 2);
    } else if (hasError) {
      for (var i = 0; i < boxWidth - 4; i += 8) {
        G.setColor(COLOR_GREEN).fillRect(boxX + 2 + i, boxY + 2, boxX + 6 + i, boxY + 4);
        G.setColor(COLOR_GREEN).fillRect(boxX + 2 + i, boxY + boxHeight - 4, boxX + 6 + i, boxY + boxHeight - 2);
      }
    }

    G.setFontMonofonto16();
    G.setColor(COLOR_GREEN);
    for (var j = 0; j < Math.min(6, playMsgLines.length); j++) {
      var line = playMsgLines[j];
      var textWidth = G.stringWidth(line);
      var lineX = boxX + Math.floor((boxWidth - textWidth) / 2);
      var lineY = boxY + 20 + j * 20;
      G.drawString(line, lineX, lineY);
    }
  }
  
  G.flip();
}

function stopPlayback() {
  if (isPlaying) {
    try { Pip.audioStop(); } catch(e) {;}
    isPlaying = false;
  }
  if (statusTimeout) {
    clearTimeout(statusTimeout);
    statusTimeout = null;
  }
  if (playMsgLines.length > 0) {
    playMsgLines = [];
    needsRedraw = true;
  }
}

function onKnob(dir) {
  stopPlayback();
  if (!wavFiles.length) return;
  var newSelected = Math.max(0, Math.min(wavFiles.length - 1, selected - dir));
  var newSelectedPage = Math.floor(newSelected / FILES_PER_PAGE);
  if (newSelectedPage !== currentPage) {
    currentPage = newSelectedPage;
  }
  selected = newSelected;
  needsRedraw = true;
}
Pip.on("knob1", onKnob);

function onPageKnob(dir) {
  stopPlayback();
  if (!wavFiles.length) return;
  var totalPages = Math.ceil(wavFiles.length / FILES_PER_PAGE);
  var newPage = Math.max(0, Math.min(totalPages - 1, currentPage - dir));
  if (newPage !== currentPage) {
    currentPage = newPage;
    var pageStart = currentPage * FILES_PER_PAGE;
    var pageEnd = Math.min(pageStart + FILES_PER_PAGE - 1, wavFiles.length - 1);
    if (selected < pageStart || selected > pageEnd) {
      selected = pageStart;
    }
    needsRedraw = true;
  }
}
Pip.on("knob2", onPageKnob);

var lastBtnState = false;
var debounceFrames = 5;
var debounceCounter = 0;

function frameLoop() {
  var btnState = typeof KNOB1_BTN !== "undefined" && KNOB1_BTN.read();
  if (debounceCounter < debounceFrames) {
    debounceCounter++;
  } else {
    if (btnState && !lastBtnState) {
      handlePlayButton();
      needsRedraw = true;
    }
  }
  lastBtnState = btnState;
  
  if (needsRedraw && !isPlaying) {
    drawMenu();
    needsRedraw = false;
  }
}
var frameInterval = setInterval(frameLoop, 100);

function handlePlayButton() {
  if (isPlaying) {
    stopPlayback();
    return;
  }
  if (!wavFiles.length) return;
  stopPlayback();
  
  var filename = wavFiles[selected];
  var fullPath = "/ALARM/" + filename;
  var results = [];
  results.push("PLAYING: " + filename.toUpperCase());

  var audioPlayed = false;
  try {
    Pip.audioStart(fullPath);
    results.push("SUCCESS: PLAYBACK STARTED");
    audioPlayed = true;
  } catch (e1) {
    results.push("FAILED: METHOD 1");
    try {
      Pip.audioStartVar(fullPath);
      results.push("SUCCESS: PLAYBACK STARTED");
      audioPlayed = true;
    } catch (e2) {
      results.push("FAILED: METHOD 2");
      try {
        var wavBuffer = require("fs").readFileSync(fullPath);
        if (wavBuffer && wavBuffer.length) {
          Pip.audioStartVar(wavBuffer);
          results.push("SUCCESS: PLAYBACK STARTED");
          audioPlayed = true;
        } else {
          results.push("FAILED: FILE READ");
        }
      } catch (e3) {
        results.push("FAILED: METHOD 3");
      }
    }
  }

  if (audioPlayed) {
    isPlaying = true;
  } else {
    results.push("WARNING: UNABLE TO PLAY FILE");
    results.push("CHECK FILE FORMAT");
  }

  playMsgLines = results;
  drawMenu();
  
  statusTimeout = setTimeout(function() {
    playMsgLines = [];
    statusTimeout = null;
    needsRedraw = true;
  }, 4000);
}

Pip.remove = function () {
  clearInterval(frameInterval);
  stopPlayback();
  Pip.removeListener("knob1", onKnob);
  Pip.removeListener("knob2", onPageKnob);
};

drawMenu();